name: 'Community Package Build Action'
description: 'Builds Manjaro/Community Packages'

inputs:
  build_env:
    description: 'Build environment (testing, stable, or aur)'
    required: true
    default: 'testing'
  source:
    description: 'Custom package repo source'
    required: false
  manjaro_branch:
    description: 'Manjaro branch to build'
    default: stable
    required: false
  custom_repo:
    description: 'Custom repo'
    required: false
  multilib:
    description: 'Build multilib package'
    required: false
    default: 'false'
  repo:
    description: 'Package repo'
    required: true
  gpg_key:
    description: 'GPG signing key'
    required: true
  gpg_passphrase:
    description: 'GPG passphrase'
    required: true
  git_branch:
    description: 'Extra repository to build package'
    required: false
  extra_command:
    description: 'Extra command to run before building'
    required: false
  extra_package:
    description: 'Extra package to build'
    required: false
  tmate:
    description: 'Run tmate for debugging'
    required: false
  repo_mirror:
    description: 'Mirror to use in build'
    default: repo
    required: false
  repo_dev:
    description: 'Development repository'
    required: false
  pacman_mirror:
    description: 'Pacman mirror URL'
    required: false
    default: 'https://nnenix.mm.fcix.net/manjaro/stable/$repo/$arch'
  publish_github:
    description: 'Publish package on GitHub'
    required: false
    default: 'true'
  push_to_repo:
    description: 'Push package to repository'
    required: false
    default: 'true'
  update_db:
    description: 'Update repository database'
    required: false
    default: 'true'
  repo_host:
    description: 'Repository host'
    required: false
  repo_user:
    description: 'Repository user'
    required: false
  repo_port:
    description: 'Repository port'
    required: false
  repo_dir:
    description: 'Repository directory'
    required: false
  github_token:
    description: 'GitHub token for authentication'
    required: true
  telegram_token:
    description: 'Telegram bot token for notifications'
    required: false
  telegram_chat_id:
    description: 'Telegram chat ID for notifications'
    required: false
  branch_type:
    description: 'Branch type (testing, stable, or aur)'
    required: true
  url:
    description: 'URL do reposit√≥rio'
    required: false
  new_branch:
    description: 'Nome do novo branch'
    required: false
  package_name:
    description: 'Nome do pacote'
    required: false
  aur_package_dir:
    description: 'Directory containing the AUR package'
    required: false
    default: '.'

# Defini√ß√£o dos passos da a√ß√£o
runs:
  using: "composite"
  steps:
    - name: Debug Inputs
      shell: bash
      run: |
        echo "DEBUG: All inputs"
        echo "${{ toJson(inputs) }}"
        echo "DEBUG: build_env from input: ${{ inputs.build_env }}"
        echo "DEBUG: build_env from env: $DEBUG_BUILD_ENV"
        echo "DEBUG: All env variables"
        env | sort
  
    # Configura√ß√£o do ambiente de build
    - name: Setup build environment
      shell: bash
      run: |
        # Atualiza o sistema e instala as depend√™ncias necess√°rias
        sudo pacman -Syu --noconfirm
        sudo pacman -S --needed --noconfirm \
          base-devel \
          cmake \
          fakeroot \
          jq \
          libarchive \
          curl \
          gnupg \
          openssl \
          zip \
          meson \
          ninja \
          yay
          
        # Verifica as vers√µes instaladas
        meson --version
        ninja --version
  
  
    - name: Configure System and Repositories
      shell: bash
      run: |
        echo "Build environment: ${{ inputs.build_env }}"
        echo "Build environment from env: $DEBUG_BUILD_ENV"
        echo "All inputs:"
        echo "${{ toJson(inputs) }}"
        echo "DEBUG: BRANCH_TYPE: $BRANCH_TYPE"
        
        # Set up pacman mirror
        echo 'Server = ${{ inputs.pacman_mirror }}' | sudo tee /etc/pacman.d/mirrorlist
        
        # Remove existing BigLinux repositories
        sudo sed -i '/biglinux/,$d' /etc/pacman.conf
        
        # Add appropriate repositories based on build environment
        if [ "${{ inputs.build_env }}" == "testing" ] || [ "$BRANCH_TYPE" == "testing" ]; then
          echo '
          [community-testing]
          SigLevel = PackageRequired
          Server = https://repo.communitybig.org/testing/$arch
          
          [biglinux-testing]
          SigLevel = PackageRequired
          Server = https://repo.biglinux.com.br/testing/$arch' | sudo tee -a /etc/pacman.conf /etc/chrootbuild/pacman.conf.x86_64
        elif [ "${{ inputs.build_env }}" == "stable" ] || [ "$BRANCH_TYPE" == "stable" ]; then
          echo '
          [community-stable]
          SigLevel = PackageRequired
          Server = https://repo.communitybig.org/stable/$arch
          
          [biglinux-stable]
          SigLevel = PackageRequired
          Server = https://repo.biglinux.com.br/stable/$arch' | sudo tee -a /etc/pacman.conf /etc/chrootbuild/pacman.conf.x86_64
        elif [ "${{ inputs.build_env }}" == "aur" ] || [ "${{ inputs.branch_type }}" == "aur" ]; then
          echo "Configurando para pacote AUR: ${{ inputs.package_name }}"
          # Configura√ß√µes espec√≠ficas para AUR
          sudo sed -i 's/^#MAKEFLAGS="-j2"/MAKEFLAGS="-j$(nproc)"/' /etc/makepkg.conf
          sudo sed -i 's/^#BUILDDIR/BUILDDIR/' /etc/makepkg.conf
          sudo sed -i 's/^#PKGDEST/PKGDEST/' /etc/makepkg.conf
          
          # Habilitar o reposit√≥rio multilib (necess√°rio para alguns pacotes AUR)
          sudo sed -i '/\[multilib\]/,/Include/s/^#//' /etc/pacman.conf
          
          # Atualizar os reposit√≥rios ap√≥s as mudan√ßas
          sudo pacman -Sy
          
          # Instalar depend√™ncias comumente necess√°rias para builds AUR
          sudo pacman -S --needed base-devel git --noconfirm
        else
          echo "Invalid branch type specified: ${{ inputs.branch_type }}"
          exit 1
        fi
        
        # Configure makepkg
        sudo sed -i '/PACKAGER=/s/.*/PACKAGER="Big Community Package Build <talesam@gmail.com>"/' /etc/makepkg.conf
        sudo sed -i '/MAKEFLAGS=/s/.*/MAKEFLAGS="-j'$(nproc)'"/' /etc/makepkg.conf
        
        # Modify manjaro-chrootbuild
        sudo sed -i 's|https://repo.manjaro.org/repo|https://nnenix.mm.fcix.net/manjaro|' /usr/lib/manjaro-chrootbuild/util.sh
        sudo sed -i '/-Syy/s/-Syy/-Syy git /' /usr/lib/manjaro-chrootbuild/util-chroot.sh

  
    # Download the source code
    - name: Download Source
      shell: bash
      run: |
        if [ "${{ inputs.build_env }}" == "aur" ]; then
          echo "Cloning AUR package from ${{ inputs.url }}"
          git clone ${{ inputs.url }} aur_package
          if [ -d "aur_package" ]; then
            cd aur_package
            if [ ! -f "PKGBUILD" ]; then
              echo "Error: PKGBUILD not found in the AUR package"
              exit 1
            fi
          else
            echo "Error: Failed to clone AUR package"
            exit 1
          fi
        elif [ -n "${{ inputs.url }}" ]; then
          echo "Cloning repository from ${{ inputs.url }}"
          git clone ${{ inputs.url }}.git source_repo
          cd source_repo
          if [ -n "${{ inputs.git_branch }}" ]; then
            echo "Checking out branch ${{ inputs.git_branch }}"
            git checkout ${{ inputs.git_branch }}
          fi
        else
          echo "No URL provided, assuming we're already in the correct repository"
        fi
        
        # Debug: Show current directory and contents
        echo "Current directory: $(pwd)"
        echo "Directory contents:"
        ls -la
  
  
    # Constr√≥i o pacote
    - name: Build package
      shell: bash
      run: |
        set -e  # Isso far√° o script falhar se qualquer comando falhar
        # Debug: Mostrar ambiente de build
        echo "Build environment: ${{ inputs.build_env }}"
        
         # Se entramos em um diret√≥rio no passo anterior, vamos garantir que estamos nele
        if [ -d "source_repo" ]; then
          cd source_repo
        fi
        
        # Debug: Mostrar diret√≥rio atual e conte√∫do
        echo "Current directory: $(pwd)"
        echo "Directory contents:"
        ls -la
        
        # Create build user
        useradd builduser -m
        passwd -d builduser
        #printf 'builduser ALL=(ALL) ALL\n' | sudo tee -a /etc/sudoers
        echo "builduser ALL=(ALL) NOPASSWD: ALL" | sudo tee -a /etc/sudoers
        
        # Create and set permissions for $PKGDEST and $SRCDEST
        sudo mkdir -p /home/packages /home/sources
        sudo chown builduser:builduser /home/packages /home/sources
        
        if [ "${{ inputs.build_env }}" == "aur" ]; then
          # Para pacotes AUR
          cd ${{ inputs.aur_package_dir }}
          echo "Construindo pacote AUR"
          echo "Current AUR package directory: $(pwd)"
          echo "AUR package directory contents:"
          ls -la
          
          if [ -f "PKGBUILD" ]; then
            echo "PKGBUILD found:"
            cat PKGBUILD
            
            # Extrair o nome real do pacote do PKGBUILD
            pkgname=$(grep -E "^pkgname=" PKGBUILD | cut -d'=' -f2 | tr -d "'\"")
            echo "Package name extracted from PKGBUILD: $pkgname"
          else
            echo "PKGBUILD not found in current directory"
            exit 1
          fi
          
          # Give permissions to builduser for the current directory
          sudo chown -R builduser:builduser .
          
          # Use yay para construir o pacote AUR
          echo "Building AUR package with yay: $pkgname"
          sudo -u builduser bash -c "yay -Sy --needed --noconfirm --builddir=/home/sources -G $pkgname"
          
          # Navegar para o diret√≥rio do pacote e compilar
          cd $pkgname
          sudo -u builduser bash -c "makepkg -si --noconfirm --needed"
          
          # Mover o pacote compilado para /home/packages
          sudo -u builduser bash -c "mv *.pkg.tar.zst /home/packages/"
        else
          # Para pacotes n√£o-AUR
          gitfolder=$(find -type f -name PKGBUILD | sed 's/PKGBUILD//')
          cd $gitfolder
          
          # Ensure architecture is set to x86_64
          sed -i "/^arch=/c\arch=('x86_64')" PKGBUILD
          
          # Build for x86_64
          echo -e "\033[01;31mBuild x86_64\033[0m"
          sudo -u builduser bash -c "sudo chrootbuild -H -p . -b ${{ inputs.branch_type }}"
        fi
        
        # Executa comando extra, se fornecido
        if [ -n "${{ inputs.extra_command }}" ]; then
          echo "Executando comando extra: ${{ inputs.extra_command }}"
          ${{ inputs.extra_command }}
        fi
        
        # Debug: Mostrar conte√∫do do diret√≥rio ap√≥s o build
        echo "Directory contents after build:"
        ls -la
        echo "Contents of /home/packages:"
        ls -la /home/packages
        echo "Contents of /home/sources:"
        ls -la /home/sources

  
    # Assina o pacote
    - name: Sign Package
      shell: bash
      run: |
        # Importa a chave GPG
        echo "${{ inputs.gpg_key }}" | gpg --batch --import &>/dev/null
        
        # Encontra o diret√≥rio que cont√©m o PKGBUILD
        gitfolder=$(find . -type f -name PKGBUILD | sed 's/PKGBUILD$//')
        if [ -z "$gitfolder" ]; then
          echo "PKGBUILD n√£o encontrado. Usando diret√≥rio atual."
          gitfolder="."
        fi
        cd "$gitfolder"
        
        # Assina todos os pacotes encontrados
        for p in $(find $PWD -maxdepth 1 -regex '.*\.pkg\.tar\.\(xz\|zst\)'); do
          echo "Assinando pacote: $p"
          gpg --pinentry-mode loopback --passphrase "${{ inputs.gpg_passphrase }}" --detach-sign "${p}"
        done
        
        # Lista os arquivos .sig gerados
        echo "Arquivos de assinatura gerados:"
        ls -l *.sig

  
    # Gera checksums para os pacotes
    - name: Generate checksums
      shell: bash
      run: |
        # Encontra o diret√≥rio que cont√©m o PKGBUILD
        gitfolder=$(find . -type f -name PKGBUILD | sed 's/PKGBUILD$//')
        if [ -z "$gitfolder" ]; then
          echo "PKGBUILD n√£o encontrado. Usando diret√≥rio atual."
          gitfolder="."
        fi
        cd "$gitfolder"
        
        # Gera checksums para pacotes e assinaturas
        for i in *.pkg.tar.zst; do
          if [ -f "$i" ]; then
            md5sum "$i" >> "$i.md5"
          fi
        done
        
        for i in *.sig; do
          if [ -f "$i" ]; then
            md5sum "$i" >> "${i%.sig}.md5"
          fi
        done
        
        # Lista os arquivos MD5 gerados
        echo "Arquivos MD5 gerados:"
        ls -l *.md5
  
  
    # Publish the package on GitHub
    - name: Publish Package on GitHub
      if: inputs.publish_github == 'true'
      shell: bash
      run: |
        gitfolder=$(find -type f -name PKGBUILD | sed 's/PKGBUILD//')
        cd $gitfolder
        ls -lh
        
        # Skip linux-zen packages
        if [ -n "$(grep linux-zen <<< $gitfolder)" ];then
          exit 0
        fi
        
        # Determine the last committer
        lastCommit=$(git log -1 --format="%an <%ae>")
        if [ "$(grep github-actions <<< $lastCommit)" ];then
          lastCommit=$(git log -2 --format="%an <%ae>")
        fi
        
        # Set up GitHub authentication and determine the repository
        if [ -n "${{ inputs.url }}" ]; then
          echo "${{ inputs.github_token }}" | gh auth login --with-token
          repo=$(echo "${{ inputs.url }}" | sed 's|https://github.com/||')
        else
          echo "${{ inputs.github_token }}" | gh auth login --with-token
          repo="${{ inputs.repo }}"
        fi
        
        # Fallback to github.repository if repo is still empty
        if [ -z "$repo" ]; then
          repo="${{ github.repository }}"
        fi
        
        # Create and upload the release
        ls *.pkg* | head -n1 | sed 's/.pkg.*//' > release
        release=$(cat release)
        
        echo "release=$release"
        echo "repo=$repo"
        echo "url=${{ inputs.url }}"
        
        if [ -n "$repo" ] && [ -n "$release" ]; then
          echo "Using repository: $repo"
          echo "Creating release: $release"
          gh release create ${release} --title ${release} --repo ${repo} --notes "automated release from ${{ inputs.url }}" || echo "release already exists"
          for i in .zst .sig .tar .md5; do
            find -iname "*$i" -exec gh release upload ${release} --repo ${repo} --clobber {} \;
          done
        else
          echo "Error: repo or release is empty"
          exit 1
        fi
  
  
    # Push the package to the repository
    - name: Push to Repo
      if: inputs.push_to_repo == 'true'
      shell: bash
      env:
        LANG: en_US.UTF-8
        LC_ALL: en_US.UTF-8
      run: |
        # Set up SSH
        ssh-keyscan -t rsa -p ${{ inputs.repo_port }} ${{ inputs.repo_host }} >> /root/.ssh/known_hosts
        ip=${{ inputs.repo_host }}
        
        # Find the PKGBUILD directory
        gitfolder=$(find -type f -name PKGBUILD | sed 's/PKGBUILD//')
        cd $gitfolder
        ls -lh
        
        # Determine the last committer
        lastCommit=$(git log -1 --format="%an <%ae>")
        if [ "$(grep github-actions <<< $lastCommit)" ];then
          lastCommit=$(git log -2 --format="%an <%ae>")
        fi
        
        # Set the branch based on BRANCH_TYPE
        if [ "${{ inputs.branch_type }}" == "stable" ]; then
          branch="STABLE"
        elif [ "${{ inputs.branch_type }}" == "aur" ]; then
          branch="AUR"
        else
          branch="TESTING"
        fi
        
        # Function to send Telegram message
        send_telegram_message() {
          message="$1"
          curl -s -X POST "https://api.telegram.org/bot${{ inputs.telegram_token }}/sendMessage" \
            -d chat_id="${{ inputs.telegram_chat_id }}" \
            -d text="$message"\
            -d parse_mode="MarkdownV2"
        }
        
        # Upload the package files
        for i in *.zst; do
          pkgname=$(basename $i)
          
          pkgname_escaped=$(echo "$pkgname" | sed 's/[_*[\]()~`>#+\-=|{}.!]/\\&/g')
          branch_escaped=$(echo "$branch" | sed 's/[_*[\]()~`>#+\-=|{}.!]/\\&/g')
          
          echo "üì¶ Pacote $pkgname sendo enviado para o reposit√≥rio üöÄ $branch üéØ"
          send_telegram_message "üì¶ **Pacote** \`$pkgname_escaped\` **sendo enviado para o reposit√≥rio** üöÄ \`$branch_escaped\`üéØ"
          rsync -vapz -e "ssh -p ${{ inputs.repo_port }}" $i ${{ inputs.repo_user }}@$ip:${{ inputs.repo_dir }}/${branch,,}/x86_64/
          if [ $? -eq 0 ]; then
            send_telegram_message "‚úÖ **Pacote** \`$pkgname_escaped\` **enviado com sucesso para o reposit√≥rio** \`$branch_escaped\`"
          else
            send_telegram_message "‚ùå **Falha ao enviar o pacote** \`$pkgname_escaped\` **para o reposit√≥rio** \`$branch_escaped\`"
          fi
        done
        for i in *.sig *.md5; do
          rsync -vapz -e "ssh -p ${{ inputs.repo_port }}" $i ${{ inputs.repo_user }}@$ip:${{ inputs.repo_dir }}/${branch,,}/x86_64/
        done


    # Runs only if previous steps were successful
    - name: Update Repository Database
      if: inputs.update_db == 'true' && success()
      shell: bash
      run: |
        # Function to send Telegram message
        send_telegram_message() {
          message="$1"
          curl -s -X POST "https://api.telegram.org/bot${{ inputs.telegram_token }}/sendMessage" \
            -d chat_id="${{ inputs.telegram_chat_id }}" \
            -d text="$message" \
            -d parse_mode="MarkdownV2"
        }
        
        # Determine the database name based on the branch type
        if [ "${{ inputs.branch_type }}" == "testing" ]; then
          branch="TESTING"
          db_name="community-testing"
        elif [ "${{ inputs.branch_type }}" == "stable" ]; then
          branch="STABLE"
          db_name="community-stable"
        elif [ "${{ inputs.branch_type }}" == "aur" ]; then
          branch="AUR"
          db_name="community-aur"
        else
          echo "Error: Unknown branch type: ${{ inputs.branch_type }}"
          exit 1
        fi
        
        echo "Branch: $branch"
        echo "Database name: $db_name"
        
        branch_escaped=$(echo "$branch" | sed 's/[_*[\]()~`>#+\-=|{}.!]/\\&/g')
        db_name_escaped=$(echo "$db_name" | sed 's/[_*[\]()~`>#+\-=|{}.!]/\\&/g')
        
        echo "üîÑ Sincronizando o banco de dados do reposit√≥rio $branch..."
        send_telegram_message "üîÑ **Iniciando sincroniza√ß√£o do banco de dados do reposit√≥rio** \`$branch_escaped\`"
        
        ssh -v ${{ inputs.repo_user }}@${{ inputs.repo_host }} -p ${{ inputs.repo_port }} << EOF
          set -x
          cd ${{ inputs.repo_dir }}/${branch,,}/x86_64
          repo-add -n -R $db_name.db.tar.gz *.pkg.tar.zst
          exit_code=\$?
          echo "Comando repo-add conclu√≠do com c√≥digo de sa√≠da: \$exit_code"
          exit \$exit_code
        EOF
        
        if [ $? -eq 0 ]; then
          echo "‚úÖ Sincroniza√ß√£o do banco de dados conclu√≠da com sucesso!"
          send_telegram_message "‚úÖ **Sincroniza√ß√£o do banco de dados do reposit√≥rio** \`$branch_escaped\` **conclu√≠da com sucesso\!**"
        else
          echo "‚ùå Falha na sincroniza√ß√£o do banco de dados."
          send_telegram_message "‚ùå **Falha na sincroniza√ß√£o do banco de dados do reposit√≥rio** \`$branch_escaped\`\."
        fi

  
    # Keeps only the most recent package
    - name: Clean Old Packages
      if: inputs.update_db == 'true' && success()
      shell: bash
      run: |
        ssh ${{ inputs.repo_user }}@${{ inputs.repo_host }} -p ${{ inputs.repo_port }} << EOF
          set -x
          cd ${{ inputs.repo_dir }}/${branch,,}/x86_64
          paccache -rk1
          echo "Comando paccache conclu√≠do com c√≥digo de sa√≠da: \$?"
        EOF


    # Send a Telegram alert if the build fails
    - name: Telegram Alert Fail
      if: failure()
      shell: bash
      run: |
        curl -s -X POST "https://api.telegram.org/bot${{ inputs.telegram_token }}/sendMessage" \
          -d chat_id="${{ inputs.telegram_chat_id }}" \
          -d text="üö® FALHA ao criar Pacote Community: ${{ github.event.action }} a partir do branch ${{ github.ref_name }}, link do erro: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }} üñ•"
